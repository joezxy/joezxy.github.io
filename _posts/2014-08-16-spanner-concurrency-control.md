# Spanner's Concurrency Control

### 1. Data Model
Spanner是一个具有事务能力的数据服务。它存储对象的集合。对象被分布到一组服务器上。每个服务器都使用Paxos状态机进行复制，每个复制组在某个时刻有一个主节点。在下面的讨论中，我们将略过复制的内部细节，将每个复制组看作是单个服务器。我们使用大写字母来标记对象，如A，B，C等

### 2. Read/Write Transaction Atomicity
读写事务使用严格的并发控制来管理，这意味着事务访问的每个数据项都将先被加锁，如果一个事务已经对某个数据项加了写锁，就不会有其他并发事务能够再在此数据项上加锁了。事务修改的所有数据对象在事务提交之后才变的可见，这使得事务是原子的。Spanner使用了一种常用的技巧来提升并发性（"optimistic execution until commit"），也就是，每个事务都将加写锁的操作推迟到提交时，在此时它执行两阶段提交协议：事务所有缓存的写请求都会尝试获得锁，只有事务提交，数据对象才真正更新，从而对外部可见。为了说明这一点，假设我们有两个对象A和B，初始值都是零，并有两个示例事务。
在例子中，EX-T1将A递增到1，EX-T2设置B为1，如果进行加锁，这个两个操作无法并发进行，而且无限制的加锁可能会导致死锁。
EX-T1: Read B and, if zero, increment A
EX-T2: Read A, and set B to A+1

Spanner在两阶段锁协议的基础上，使用了wound-wait的锁获取策略，以避免死锁。EX-T1可能在"EX-T2获取了A的读锁以及B的写锁"后才开始，这将导致EX-T2重新运行（rewind），而EX-T1自己会将A设置为1，在EX-T2重新执行后，会将B设置为2。
wound-wait 用于避免死锁。当一个事务请求进行Prepare操作（读／写），但和另一个正在进行的事务的读写操作冲突时，我们根据事务的ID来确定如何解决冲突。ID较早的事务被wound，而ID较晚的事务将等待

wait：被延迟，直到冲突的事务终止（中止或提交）

wound：发一个广播请求，要求冲突的事务重启，而后等到冲突事务真正完成重启再继续。
到此为止，还没有出现支撑Spanner运行的那些复杂的机制：版本、时间戳等等。我们现在来讨论快速只读事务，这将给系统增加一个全新的维度。

### 3. Read-Only Transaction
大多数事务是只读的，而且还有长时间运行的计算，如数据分析。我们常想将只读事务与读写事务区分执行。Spanner将这些只读事务称为免锁，以代表事务本身不会对任何数据项加锁，因此不会对读写事务的运行造成影响。


不幸的是，即使读写事务的执行是原子的，不使用锁来读取多个对象将会得到不一致的快照。为了说明这种情况，再次考虑上面的EX-T1和EX-T2事务，我们增加另一个事务EX-T3，其会读取A和B。一个不受限的执行可能会导致EX-T3看到A＝0（在所有提交之前）以及B＝2（在EX-T1和EX-T2都提交之后）。我们希望一个只读事务能够看到的是执行读写事务的原子操作所得到的数据库的状态，而不用锁的方式来解决这一问题的唯一方法是使用数据版本机制，为相同数据对象保存多个版本。


带有一个全局排序源的数据版本是这样工作的。我们按照全局事务提交顺序为每个版本分配一个时间戳，并将此事务中的所有写操作都标记上这个时间戳。通过请求读取某个时间戳之前的数据版本，客户端可以读取到一个一致的快照。


在上一个例子中，如果EX-T1先提交，我们为其分配时间戳1；而后是EX-T2提交，分配时间戳2。执行EX-T3的客户端可能会请求读取快照0（在所有提交之前）；快照1（在EX-T1提交后，但在EX-T2提交前）；或者是快照2（所有提交之后）。重要的是，数据版本也带来了潜在的延迟。例如，在上面的场景中，读取快照2必须等到EX-T2完成。因此虽然只读事务不会对任何数据加锁，但其自身可能会被阻塞以等待读写事务的完成。


### 4. Choosing Timestamp
我们现在描述Spanner是如何为读写事务分配时间戳的，以及如何为只读事务选择时间戳，从而（1）避免中心控制；（2）最小化读阻塞。下面两个非正式的规则描述了Spanner中如何为事务选择时间戳
规则1：T的时间戳是一个真实时间，此时间在所有读返回之后，以及在事务释放任意的锁之前。
规则2：每个参与者贡献事务时间戳T的一个下限：每个参与者的下限大于之前本地写入的任意时间戳。
这些规则提供了下面的属性：
由规则1，如果事务T1在事务T2结束后启动，则T1必须有一个比T2大的时间戳
由规则2，如果事务T1读取了事务T2写入的一些数据，则T1必须有一个比T2大的时间戳（需要注意即使是T1启动早于T2结束也是这样——时间戳的分配不是事务启动时分配的）
由规则2，如果事务T1覆盖了事务T2之前写入的数据，则T1必须有一个比T2大的时间戳
此外，这些规则意味着：在响应一个读数据请求（其时间戳小于该服务器已为正在运行的事务提出的区间）之前，服务器是不用阻塞的。
构建一个支持这两条规则的分布式协议并不困难。事实上，在事务执行结束时的2PC协议使用它是非常自然的。如下面所示：第一个阶段收集下限以决定事务的时间戳，而后在提交阶段指定参与者使用相应的时间戳来作为他们的版本号，来执行pending的写操作，并使修改可见。

#### 两阶段提交中的时间戳选择
阶段1（Prepare）

非协调者：
当被要求锁定数据用于写时，每个非协调的参与者选择一个Prepare时间
TSlocal，作为协调者最终分配给此事务的时间戳的下限。TSlocal满足（1）比本地数据关联的任意时间戳都大；（2）比之前的Prepare时发送的任意下限都大

协调者：
协调者的下限相对与其之前的写操作是单调递增的，此外还被限制为严格大于当前的实际时间。也就是说，它的下限大于所有事务读操作完成的时间。（一些实践中的注意点，Spanner协调者的第一个动作就是读取本地时钟，以最小化由于时钟偏移造成的阶段2过程中的强制等待。同时Spanner的协调者延迟自己加写锁的操作，直到从所有的参与者处收集到了响应，这样可以使得并发最大化。）

每个参与者（包括协调者）都记录Prepare时间，以用于拒绝更晚时间的读请求，直到事务结束

阶段2（Commit）
从参与者处收集到的下限的最大值，被做为此事务的时间戳。协调者在提交所有写操作并释放锁之前，强制等待到经过事务时间戳的实际时间
在提交时，每个参与者移除与此事务关联的Prepare时间，并移除关联数据的读限制。

为了应对时钟偏移问题，Spanner使用了一种近似时钟服务TrueTime，其提供了读实际时间区间的服务（类似于Marzullos时间服务器）。Spanner协调者在2PC开始时读取TrueTime，而后在提交之前延迟足够长的时间，以保证它为事务选中的时间戳已经在实际时钟中经过了。


### 5. Choosing Timestamps for Read-Only Transaction
为了让一个只读事务中的读操作支持linearizability，它必须能够返回读开始前最新提交的数据。这需要通过请求TrueTime的上限来实现，因为任何在这一时刻前结束的事务都有一个更小的时间戳。
然而，使用这个时间戳可能会导致事务等待。因此某种特殊场景下，如针对单个服务器的只读查询，Spanner会发送一个特殊的读请求，来告知此服务器去使用本地写数据所用的最新时间戳。如果没有正在运行的冲突事务，则读请求可以立刻返回。
Spanner也支持针对任意快照时间的只读事务，这也被称为"快照读"。


### 6. Concluding Remarks
正如之前所说，我们已省略了许多的细节，只留下了事务并发控制的部分。特别的，事务和时间戳的管理在Spanner中是和2PC协议交织在一起的。因此对于协议的完整描述将包括用于恢复的日志，以及每个参与者需要进行的Paxos复制。此外，我们也没有描述故障时如何重新获取锁。Spanner客户端发送keepalive消息给事务Leader，所有的事务参与者都自身进行复制以达到容错。

论文中对于时间戳管理的描述中说，协调者贡献一个下限值，其大于任意的"timestamp the leader has assigned to previous transactions"。"assigned"的含义可能不是完全的有二义性的，因为只有一个事务协调者才会选择／分配时间戳。在上面的描述中，我们明确了下限值应该大于任何之前已写入数据所关联的时间戳。
一个例子：首先，协调者读取它的本地时钟，来设置自己的下限TSlocal，然后它以非协调者的身份接收到一个提交消息，此消息是由其他的事务T发出的，而且事务T的时间戳大于TSlocal，然后它使用时间戳TSlocal提交了事务T。

最终，我们可以将Spanner的并发控制方法总结为：Spanner使用了2PC来排序读写事务。Spanner的2PC实现中不同之处在于：（1）将写锁的获取延迟到某个事务结束后，（2）使用wound-wait来解决死锁。

并发控制协议中最复杂的是由于只读事务。支持这些事务必须：（1）维护数据项的多个版本，（2）为读写事务选择时间戳，（3）提供"读某个时间戳的数据"的服务。

「Google Spanner的研发人员对文章的早期版本提出了建议」
